C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\key.obj
COMPILER INVOKED BY: F:\tool_start\keil_c51\C51\BIN\C51.EXE ..\App\key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\App\inc;..\D
                    -river\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\key.lst) TABS(2) OBJECT(.\Objects\key.obj)

line level    source

   1          #include "key.h"
   2          
   3          uint8_t gulKeyValue;
   4          xSysStatus_t sx_SysStatus;
   5          
   6          void Perpheral_En(void);
   7          void Perpheral_Dis(void);
   8          void OSTickScan(void);
   9          void PowerOnOff_Set(uint8_t value)
  10          {
  11   1        //b_FanRotateErrorFlag_Set(0);
  12   1        sx_SysStatus.b_OnOffFlag=value;
  13   1        b_FightLighTouchFanBusy_Set(0);
  14   1        sx_FightLightStatus.b_FightDisplayBusy = true;
  15   1        b_KeyPressFlag_Set(0);
  16   1        //if(b_SleepMode_Get()!=SLEEP_MODE_SLEEP)
  17   1        ul_SleepModeCnt_Set(0);
  18   1        if(value){    //开机
  19   2          LED_SensetypeFlag_Set(LED_SENSE_ON);
  20   2          b_SleepMode_Set(SLEEP_MODE_WAKE);
  21   2          b_DetInitFlag_Set(DETECTIVE_INIT_ON);
  22   2          //ErrorType_Reset(ERROR_TYPE_ALL);
  23   2          Perpheral_En();
  24   2          uc_Level_Set(sx_SysStatus.uc_Level);
  25   2          uc_LevelSum_Set(uc_Mode_Get()+6*(sx_SysStatus.uc_Level-1));
  26   2          //set_led_event(LED_EVENT_SENCE);
  27   2        }else{      //关机
  28   2          if(b_SleepMode_Get()==SLEEP_MODE_SLEEP)
  29   2            LED_SensetypeFlag_Set(LED_SENSE_SLEEP);
  30   2          else
  31   2            LED_SensetypeFlag_Set(LED_SENSE_ON);
  32   2          sx_SysStatus.b_AutoSwitchFlag=0;
  33   2          b_DetInitFlag_Set(DETECTIVE_INIT_BOOT);
  34   2          Perpheral_Dis();
  35   2          if(!b_BurninFlag_Get())set_led_event(LED_EVENT_OFF);
  36   2        }
  37   1        
  38   1      }
  39          
  40          void Key_Handler(void)
  41          {
  42   1        uint8_t i=0;
  43   1        
  44   1        OSTickScan();
  45   1        if(ErrorType_Get()/*&(ERROR_TYPE_VOLTAGE|ERROR_TYPE_SUPPLY)*/){
  46   2          gulKeyValue = CKEY_NULL;
  47   2          return;
  48   2        }
  49   1        if(BurninEntering()){
  50   2          gulKeyValue = CKEY_NULL;
  51   2          return;
  52   2        }
  53   1        if(b_BurninFlag_Get()){
  54   2          if(gulKeyValue==CKEY_RLS_S1&&!b_BurninStart_Get()){
C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 2   

  55   3            PowerOnOff_Set(1);
  56   3            b_BurninCntStart_Set(1);
  57   3            LED_SensetypeFlag_Set(LED_SENSE_TOUCH);
  58   3          }
  59   2          gulKeyValue = CKEY_NULL;
  60   2          return;
  61   2        }
  62   1        if(b_SleepMode_Get()==SLEEP_MODE_SLEEP){
  63   2          if(gulKeyValue==CKEY_RLS_S1){
  64   3            PowerOnOff_Set(1);
  65   3            set_led_event(LED_EVENT_MODE);
  66   3          }
  67   2          gulKeyValue = CKEY_NULL;
  68   2          return;
  69   2        }
  70   1        switch(gulKeyValue)
  71   1        {
  72   2          default:break;
  73   2          case CKEY_RLS_S1:{
  74   3      //      i=!i;
  75   3      //      if(i) SMG_Write_Byte(0x20);
  76   3      //      else SMG_Write_Byte(0x00);
  77   3            if(sx_SysStatus.b_OnOffFlag)
  78   3            {
  79   4              if(!sx_SysStatus.b_AutoSwitchFlag)
  80   4                b_KeyPressFlag_Set(1);
  81   4            }
  82   3            ul_SleepModeCnt_Set(0);
  83   3          }break;
  84   2          case CKEY_HLD_S1:{
  85   3            if(sx_SysStatus.b_OnOffFlag)
  86   3            {
  87   4              if(!sx_SysStatus.b_AutoSwitchFlag){
  88   5                sx_SysStatus.b_AutoSwitchFlag = 1;
  89   5                set_led_event(LED_EVENT_AUTO);
  90   5              }
  91   4            }
  92   3            ul_SleepModeCnt_Set(0);
  93   3          }break;
  94   2        }
  95   1        gulKeyValue = CKEY_NULL;
  96   1      }
  97          
  98          
  99          
 100          
 101          void Perpheral_En(void)
 102          {
 103   1        uc_FanKeepFlagSet(FAN_ON);
 104   1        //FAN_FULLSPEED();
 105   1        FAN_ON();
 106   1        Pwm_Set(CHARGE_FRE,0);
 107   1        _nop_();
 108   1        Pwm_Open_Charge();
 109   1        RELEASE_400V_DIS();
 110   1        sx_ChargeStatus.uc_curpwmduty = 0;
 111   1      }
 112          
 113          void Perpheral_Dis(void)
 114          {
 115   1        Pwm_Close_Charge();
 116   1        RELEASE_400V_EN();
C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 3   

 117   1        if((ErrorType_Get()&~(ERROR_TYPE_FAN|ERROR_TYPE_NTC)) || b_BurninFlag_Get()){
 118   2          FAN_OFF();
 119   2          uc_FanKeepFlagSet(FAN_BOOT);
 120   2        }else if(!ErrorType_Get()){
 121   2          uc_FanKeepFlagSet(FAN_OFF);
 122   2          FAN_HALFSPEED();
 123   2        }
 124   1      }
 125          
 126          type_sKSCtrl strKSCtrl;
 127          
 128          uint32_t Key_Scan()
 129          {
 130   1        uint8_t ulKIO,ulTemp;
 131   1        uint8_t Key_Data;
 132   1        uint8_t ul;
 133   1        uint8_t bFlag,bRetFlag;
 134   1      
 135   1        bRetFlag = false; //假定无有效键输出
 136   1      
 137   1        //scan board and get physical key code
 138   1          bFlag = false;
 139   1        while(1)
 140   1        {
 141   2          Key_Data = 0xff;
 142   2          if(!KEY_LIGHT)
 143   2            Key_Data &= ~(0x01<<0);   //打光键
 144   2            
 145   2          Key_Data = ~Key_Data;
 146   2            
 147   2          ulKIO = Key_Data&IO_KEY;
 148   2      
 149   2          for(ul=0; ul<20; ul++);
 150   2          ulTemp = Key_Data&IO_KEY;
 151   2          if(ulTemp != ulKIO)
 152   2            break;
 153   2          
 154   2          //连续数次后认为一次稳定物理输入
 155   2          bFlag = true;
 156   2          break;
 157   2        }
 158   1        //得到原始物理键值
 159   1        if(!bFlag)
 160   1          return CKEY_NULL; //键盘没有一个稳定状态，忽虑
 161   1      
 162   1        
 163   1        //得到一次稳定状态，开始逻辑判断
 164   1        //strKSCtrl.ulKIOState = ulKIO;
 165   1        
 166   1      
 167   1        strKSCtrl.ulKeyCur = ulKIO;
 168   1      
 169   1        switch(strKSCtrl.ucScanStep)
 170   1        {
 171   2        case CKSTEP_NULL:
 172   2          if(strKSCtrl.ulKeyCur == 0x00)
 173   2            break;  //没有任何键压下
 174   2          
 175   2          strKSCtrl.ulCodeTemp = strKSCtrl.ulKeyCur;
 176   2          strKSCtrl.ucScanCnt = 1;
 177   2          strKSCtrl.ucScanStep = CKSTEP_PRESS;
 178   2          
C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 4   

 179   2          break;
 180   2      
 181   2        case CKSTEP_PRESS:
 182   2          if(strKSCtrl.ulKeyCur != strKSCtrl.ulCodeTemp)
 183   2          {
 184   3              strKSCtrl.ulCodeTemp = CKEY_NULL;
 185   3              strKSCtrl.ucScanCnt = 0;
 186   3              strKSCtrl.ucScanStep = CKSTEP_NULL;
 187   3      
 188   3          }
 189   2          else
 190   2          {
 191   3            if(CKCONFIRM_TIMES == strKSCtrl.ucScanCnt ++)
 192   3            {
 193   4              strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp;
 194   4              bRetFlag = true;
 195   4              strKSCtrl.ucScanStep = CKSTEP_HOLD;
 196   4            }
 197   3          }
 198   2      
 199   2          break;
 200   2      
 201   2        case CKSTEP_HOLD:
 202   2          if(strKSCtrl.ulKeyCur != strKSCtrl.ulCodeTemp)
 203   2          { 
 204   3            strKSCtrl.ucScanStep = CKSTEP_RLS;
 205   3            //strKSCtrl.ucScanCnt = CKCONFIRM_TIMES;
 206   3            
 207   3          }
 208   2          else
 209   2          {
 210   3            strKSCtrl.ucScanCnt++;
 211   3            if(CHOLDKEY_TIME == strKSCtrl.ucScanCnt - CKCONFIRM_TIMES)
 212   3            {
 213   4              strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp<<1;
 214   4              bRetFlag = true;
 215   4              strKSCtrl.ucScanStep = CKSTEP_HOLDRPT;
 216   4              //strKSCtrl.ucScanCnt = CKCONFIRM_TIMES;
 217   4            }
 218   3          }
 219   2      
 220   2          break;
 221   2      
 222   2        case CKSTEP_HOLDRPT:
 223   2          if(strKSCtrl.ulKeyCur != strKSCtrl.ulCodeTemp)
 224   2            strKSCtrl.ucScanStep = CKSTEP_RLS;
 225   2            //strKSCtrl.ucScanCnt = CKCONFIRM_TIMES;
 226   2          else
 227   2            strKSCtrl.ucScanStep = CKSTEP_RLS;
 228   2          break;
 229   2      
 230   2        case CKSTEP_RLS:
 231   2          if(strKSCtrl.ulKeyCur == 0x00)
 232   2          { //无任何键按下
 233   3            
 234   3            if(strKSCtrl.ucScanCnt++ >= CKCONFIRM_TIMES+CKCONFIRM_TIMES)
 235   3            {
 236   4      //        test=!test;
 237   4      //      if(test) SMG_Write_Byte(0x08);
 238   4      //      else SMG_Write_Byte(0x00);
 239   4                if(strKSCtrl.ucScanCnt<CPRESSKEY_TIME)
 240   4                  //strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp + (strKSCtrl.ulCodeTemp<<3);
C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 5   

 241   4                  strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp<<2;
 242   4                else if(strKSCtrl.ucScanCnt>CHOLDKEY_TIME)
 243   4                  //strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp + (strKSCtrl.ulCodeTemp<<1) + (strKSCtrl.ulCodeTemp<<3)
             -;
 244   4                  strKSCtrl.ulKeyCode = strKSCtrl.ulCodeTemp<<3;
 245   4                if(BurninEntering())
 246   4                  set_led_event(LED_EVENT_SENCE);
 247   4                b_BurninReadyFlag_Set(0);
 248   4                bRetFlag = true;
 249   4                strKSCtrl.ulCodeTemp = CKEY_NULL;
 250   4                strKSCtrl.ucScanCnt = 0;
 251   4                strKSCtrl.ucScanStep = CKSTEP_NULL;
 252   4            }
 253   3          }
 254   2          else
 255   2          { //仍有键被压下
 256   3      //      if(strKSCtrl.ulKeyCur != strKSCtrl.ulCodeTemp)
 257   3      //      { //未放手又有新的键被压下
 258   3      //        strKSCtrl.ulCodeTemp = CKEY_NULL;
 259   3      //        strKSCtrl.ucScanCnt = 0;
 260   3      //        strKSCtrl.ucScanStep = CKSTEP_NULL;
 261   3      //      }
 262   3            //else 仍然是上次按键未放开，无动作；直到放开或新的按下
 263   3          }
 264   2      
 265   2          break;
 266   2        }
 267   1        
 268   1        if(bRetFlag == true)
 269   1          return strKSCtrl.ulKeyCode;
 270   1        else
 271   1          return CKEY_NULL;
 272   1      }
 273          
 274          void OSTickScan(void)
 275          {
 276   1        uint8_t ulT;
 277   1        
 278   1      
 279   1        ulT = Key_Scan();
 280   1        if(CKEY_NULL != ulT)
 281   1        {
 282   2          strKSCtrl.ulKeyCode = CKEY_NULL;
 283   2          gulKeyValue = ulT;
 284   2        }
 285   1        
 286   1      }
 287          
 288          void Key_init(void)
 289          {
 290   1        strKSCtrl.ulKeyCode = CKEY_NULL;
 291   1        strKSCtrl.ulCodeTemp = CKEY_NULL;
 292   1        strKSCtrl.ulKeyCur = CKEY_NULL;
 293   1        strKSCtrl.ucScanCnt = 0;
 294   1        strKSCtrl.ucScanStep = CKSTEP_NULL;
 295   1        //strKSCtrl.usHoldTime= CHOLDKEY_TIME/CSYSTICK_BASE;
 296   1        //strKSCtrl.usHoldRPTTime = CHOLDRPTKEY_TIME/CSYSTICK_BASE;
 297   1        gulKeyValue = CKEY_NULL;
 298   1        
 299   1        sx_SysStatus.uc_Mode = 0;
 300   1        sx_SysStatus.uc_Level = 0;
 301   1        sx_SysStatus.uc_LevelSum = 0;
C51 COMPILER V9.60.7.0   KEY                                                               04/16/2024 15:41:19 PAGE 6   

 302   1      }
 303          
 304          
 305          
 306          
 307          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    675    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
