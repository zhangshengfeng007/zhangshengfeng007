C51 COMPILER V9.60.7.0   DISPLAY                                                           04/16/2024 15:41:18 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Objects\display.obj
COMPILER INVOKED BY: F:\tool_start\keil_c51\C51\BIN\C51.EXE ..\App\display.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\App\inc;
                    -..\Driver\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\display.lst) TABS(2) OBJECT(.\Objects\display.obj)

line level    source

   1          #include "display.h"
   2          
   3          xdata xDisplayStatus_t sx_DisplayStatus_t={0};
   4          
   5          extern uint8_t errordisplay_buf;
   6          void Display_Handler(void)
   7          {
   8   1        uint8_t displayflag = false;
   9   1        
  10   1      //  if(sx_DisplayStatus_t.b_Event){
  11   1      //    if(vrefunstableflag)return;
  12   1      //  }
  13   1        if(b_IPLWorking_Get())return;
  14   1        
  15   1        if(!ErrorType_Get()/*sx_DisplayStatus_t.b_ScanCnt==10*/)
  16   1        {
  17   2          if(sx_DisplayStatus_t.b_Event & LED_EVENT_CLEAR){
  18   3            sx_DisplayStatus_t.b_Event &= ~LED_EVENT_CLEAR;
  19   3            LED_send_buf&=~(LED_EVENT_MODE|LED_AUTO);
  20   3          }
  21   2          #if 1
  22   2          //if(b_DetInitFlag_Get()==DETECTIVE_INIT_FINISH){
  23   2            if(sx_DisplayStatus_t.b_Event & LED_EVENT_MODE)   //模式灯
  24   2            {
  25   3              sx_DisplayStatus_t.b_Event &= ~LED_EVENT_MODE;
  26   3              LED_send_buf&=~LED_MODE;
  27   3              switch(uc_Mode_Get())
  28   3              {
  29   4                case 0:LED_send_buf|=LED_MODE_1;break;
  30   4                case 1:LED_send_buf|=LED_MODE_2;break;
  31   4                case 2:LED_send_buf|=LED_MODE_3;break;
  32   4                case 3:LED_send_buf|=LED_MODE_4;break;
  33   4                case 4:LED_send_buf|=LED_MODE_5;break;
  34   4                case 5:LED_send_buf|=LED_MODE_6;break;
  35   4              }
  36   3              displayflag = true;
  37   3      //        SMG_Write_Byte(LED_send_buf);
  38   3      //        return;
  39   3            }
  40   2            if(sx_DisplayStatus_t.b_Event & LED_EVENT_AUTO)   //自动打光灯
  41   2            {
  42   3              sx_DisplayStatus_t.b_Event &= ~LED_EVENT_AUTO;
  43   3              LED_send_buf&=~LED_AUTO;
  44   3              if(b_AutoSwitchFlag_Get())
  45   3                LED_send_buf|=LED_AUTO;
  46   3              displayflag = true;
  47   3      //        SMG_Write_Byte(LED_send_buf);
  48   3      //        return;
  49   3            }
  50   2          //}
  51   2          if(sx_DisplayStatus_t.b_Event & LED_EVENT_BURNIN)   //老化模式
  52   2          {
  53   3            sx_DisplayStatus_t.b_Event &= ~LED_EVENT_BURNIN;
  54   3            LED_send_buf&=~LED_ALL;
C51 COMPILER V9.60.7.0   DISPLAY                                                           04/16/2024 15:41:18 PAGE 2   

  55   3            LED_send_buf|=LED_ALL;
  56   3            if(!b_BurninMode_Get())
  57   3              LED_send_buf&=~LED_MODE_6;
  58   3            else
  59   3              LED_send_buf&=~LED_AUTO;
  60   3            displayflag = true;
  61   3      //      SMG_Write_Byte(LED_send_buf);
  62   3      //      return;
  63   3          }
  64   2          if(sx_DisplayStatus_t.b_Event & LED_EVENT_OFF)    //关闭所有灯
  65   2          {
  66   3            sx_DisplayStatus_t.b_Event &= ~LED_EVENT_OFF;
  67   3            LED_send_buf&=(LED_OFF);
  68   3            LEDB = 1;
  69   3            displayflag = true;
  70   3      //      SMG_Write_Byte(LED_send_buf);
  71   3      //      return;
  72   3          }
  73   2          if(sx_DisplayStatus_t.b_sensetype==LED_SENSE_SLEEP)   //呼吸灯
  74   2          {
  75   3            sx_DisplayStatus_t.b_Event &= ~LED_EVENT_SENCE;
  76   3      //      if(/*sx_DisplayStatus_t.b_senseonoffflag&&*/sx_DisplayStatus_t.b_sensebreathduty!=0&&sx_DisplayStatus
             -_t.b_sensebreathduty!=20){
  77   3      //      //if(sx_DisplayStatus_t.uc_senseonoffcnt<100/*&&!sx_DisplayStatus_t.b_senseonoffflag*/)
  78   3      //        //sx_DisplayStatus_t.uc_senseonoffcnt++;
  79   3      //        if(sx_DisplayStatus_t.uc_senseonoffcnt==sx_DisplayStatus_t.b_sensebreathduty){
  80   3      //          LED_send_buf|=LED_SENCE;
  81   3      //          displayflag = true;
  82   3      //        }else if(sx_DisplayStatus_t.uc_senseonoffcnt==20){
  83   3      //          LED_send_buf&=~LED_SENCE;
  84   3      //          displayflag = true;
  85   3      //          sx_DisplayStatus_t.uc_senseonoffcnt = 0;
  86   3      //        }
  87   3      //      }
  88   3      //      else{
  89   3      //        if(sx_DisplayStatus_t.b_sensebreathduty==0)
  90   3      //          LED_send_buf|=LED_SENCE;
  91   3      //        else if(sx_DisplayStatus_t.b_sensebreathduty==20)
  92   3      //          LED_send_buf&=~LED_SENCE;
  93   3      //        sx_DisplayStatus_t.b_senseonoffflag = 0;
  94   3      //        displayflag = true;
  95   3      //      }
  96   3          }
  97   2          if(sx_DisplayStatus_t.b_Event & LED_EVENT_SENCE)    //感应灯
  98   2          {
  99   3            sx_DisplayStatus_t.b_Event &= ~LED_EVENT_SENCE;
 100   3            switch(sx_DisplayStatus_t.b_sensetype)
 101   3            {
 102   4              case LED_SENSE_ON:LEDB = 0;break;
 103   4              case LED_SENSE_ROTARY:
 104   4              case LED_SENSE_TOUCH:
 105   4                if(!sx_DisplayStatus_t.b_senseonoffflag)
 106   4                  LEDB = 0;
 107   4                else
 108   4                  LEDB = 1;
 109   4                break;
 110   4            }
 111   3          //  displayflag = true;
 112   3      //      SMG_Write_Byte(LED_send_buf);
 113   3      //      return;
 114   3          }
 115   2          #endif
C51 COMPILER V9.60.7.0   DISPLAY                                                           04/16/2024 15:41:18 PAGE 3   

 116   2      //    if(displayflag)
 117   2      //      SMG_Write_Byte(LED_send_buf);
 118   2          if((!vrefunstableflag && !sx_FightLightStatus.b_FightDisplayBusy) || displayflag)
 119   2          {SMG_Write_Byte(LED_send_buf);SMG_Write_Byte(LED_send_buf);}
 120   2        }
 121   1        else{
 122   2      //    if(sx_DisplayStatus_t.b_Event & LED_EVENT_ERROR){
 123   2      //      sx_DisplayStatus_t.b_Event &= ~LED_EVENT_ERROR;
 124   2      //    }
 125   2          SMG_Write_Byte(errordisplay_buf);
 126   2        }
 127   1        
 128   1      }
 129          
 130          void Display_Breath_Cb(void)
 131          {
 132   1      //  if(sx_DisplayStatus_t.b_sensetype==LED_SENSE_SLEEP){
 133   1      //    if(sx_DisplayStatus_t.uc_senseonoffcnt<100&&!sx_DisplayStatus_t.b_senseonoffflag){
 134   1      //      sx_DisplayStatus_t.uc_senseonoffcnt++;
 135   1      //      sx_DisplayStatus_t.b_senseonoffflag = 1;
 136   1      //    }
 137   1      //    if(!sx_DisplayStatus_t.b_senseonoffflag&&sx_DisplayStatus_t.b_sensebreathduty!=0&&sx_DisplayStatus_t.b
             -_sensebreathduty!=100){
 138   1      //      if(sx_DisplayStatus_t.uc_senseonoffcnt==sx_DisplayStatus_t.b_sensebreathduty){
 139   1      //        sx_DisplayStatus_t.b_senseonoffflag = 1;
 140   1      //      }else if(sx_DisplayStatus_t.uc_senseonoffcnt==100){
 141   1      //        sx_DisplayStatus_t.b_senseonoffflag = 2;
 142   1      //        sx_DisplayStatus_t.uc_senseonoffcnt = 0;
 143   1      //      }
 144   1      //    }
 145   1      //  }
 146   1        if(sx_DisplayStatus_t.b_sensetype==LED_SENSE_SLEEP){
 147   2          if(++sx_DisplayStatus_t.uc_senseonoffcnt==sx_DisplayStatus_t.b_sensebreathduty){
 148   3            LEDB = 1;
 149   3          }else if(sx_DisplayStatus_t.uc_senseonoffcnt==22){
 150   3            LEDB = 0;
 151   3            sx_DisplayStatus_t.uc_senseonoffcnt = 0;
 152   3          }
 153   2        }
 154   1      }
 155          
 156          void Display_Cb(void)
 157          {
 158   1        //uint16_t sense_fre = 0;
 159   1        
 160   1        //感应灯
 161   1        if((sx_DisplayStatus_t.b_sensetype==LED_SENSE_ROTARY ||  sx_DisplayStatus_t.b_sensetype==LED_SENSE_TOUCH)
             - \
 162   1              /*&& b_OnOffFlag_Get() && (!(sx_DisplayStatus_t.b_Event & LED_EVENT_SENCE))*/)
 163   1        {
 164   2          if(++sx_DisplayStatus_t.uc_senseonoffcnt==sx_DisplayStatus_t.sense_fre){
 165   3            sx_DisplayStatus_t.b_senseonoffflag = true;
 166   3            set_led_event(LED_EVENT_SENCE);
 167   3          }
 168   2          if(sx_DisplayStatus_t.uc_senseonoffcnt==sx_DisplayStatus_t.sense_fre*2){
 169   3            sx_DisplayStatus_t.uc_senseonoffcnt = 0;
 170   3            sx_DisplayStatus_t.b_senseonoffflag = false;
 171   3            if(sx_DisplayStatus_t.b_sensetype==LED_SENSE_ROTARY)
 172   3              sx_DisplayStatus_t.b_sensetype = LED_SENSE_ON;
 173   3            set_led_event(LED_EVENT_SENCE);
 174   3          }
 175   2        }
C51 COMPILER V9.60.7.0   DISPLAY                                                           04/16/2024 15:41:18 PAGE 4   

 176   1        else if(sx_DisplayStatus_t.b_sensetype==LED_SENSE_SLEEP){
 177   2      //    if(sx_DisplayStatus_t.uc_senseonoffcnt<20)
 178   2      //      sx_DisplayStatus_t.uc_senseonoffcnt++;
 179   2          if(++sx_DisplayStatus_t.b_sensebreathjustcnt%100==0)
 180   2          {
 181   3            if(!sx_DisplayStatus_t.b_sensebreathjustdir){
 182   4              if(++sx_DisplayStatus_t.b_sensebreathduty==21){
 183   5                sx_DisplayStatus_t.b_sensebreathjustdir = 1;
 184   5                sx_DisplayStatus_t.b_sensebreathjustcnt = 0;
 185   5                //LEDB = 0;
 186   5              }
 187   4              
 188   4            }else{
 189   4              if(--sx_DisplayStatus_t.b_sensebreathduty==1){
 190   5                sx_DisplayStatus_t.b_sensebreathjustdir = 0;
 191   5                sx_DisplayStatus_t.b_sensebreathjustcnt = 0;
 192   5                //LEDB = 1;
 193   5              }
 194   4            }
 195   3          }
 196   2        }
 197   1        else{
 198   2          sx_DisplayStatus_t.uc_senseonoffcnt = 0;
 199   2          sx_DisplayStatus_t.b_senseonoffflag = 0;
 200   2        }
 201   1      }
 202          
 203          void Display_init(void)
 204          {
 205   1        SMG_Write_Byte(0);
 206   1        sx_DisplayStatus_t.b_Event = 0;
 207   1        sx_DisplayStatus_t.sense_fre = 10000;
 208   1        LED_send_buf = 0x00;
 209   1        if(!BurninEntering())
 210   1          set_led_event(LED_EVENT_SENCE);
 211   1      }
 212          
 213          void LED_SensetypeFlag_Set(uint8_t value)
 214          {
 215   1        sx_DisplayStatus_t.b_sensetype=value;
 216   1        sx_DisplayStatus_t.uc_senseonoffcnt = 0;
 217   1        sx_DisplayStatus_t.b_senseonoffflag = false;
 218   1        if(value==LED_SENSE_ROTARY)
 219   1          sx_DisplayStatus_t.sense_fre = 300;
 220   1        else if(value==LED_SENSE_TOUCH)
 221   1          sx_DisplayStatus_t.sense_fre = 500;
 222   1        else if(value==LED_SENSE_SLEEP){
 223   2          sx_DisplayStatus_t.b_sensebreathjustcnt = 0;
 224   2          sx_DisplayStatus_t.b_sensebreathjustdir = 1;
 225   2          sx_DisplayStatus_t.b_sensebreathduty = 21;
 226   2        }else
 227   1          sx_DisplayStatus_t.sense_fre = 10000;
 228   1        set_led_event(LED_EVENT_SENCE);
 229   1        //RKSwitchFlag_Set(0);
 230   1      }
 231          
 232          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    636    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.7.0   DISPLAY                                                           04/16/2024 15:41:18 PAGE 5   

   XDATA SIZE       =     12    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
